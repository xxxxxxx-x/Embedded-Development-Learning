#include <arpa/inet.h>
#include <fcntl.h>
#include <net/if.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>

// 定义 BMP 文件头结构体
typedef struct {
  unsigned short bfType;      // 文件类型，通常为0x4D42（'BM'）
  unsigned int bfSize;        // 文件大小，以字节为单位
  unsigned short bfReserved1; // 保留字段，通常为0
  unsigned short bfReserved2; // 保留字段，通常为0
  unsigned int bfOffBits;     // 从文件头到图像数据的偏移量
} __attribute__((packed)) BITMAPFILEHEADER;

// 定义 BMP 位图信息头结构体
typedef struct {
  unsigned int biSize;  // 位图信息头的大小，通常为40字节
  unsigned int biWidth; // 图像宽度，以像素为单位
  unsigned int biHeight; // 图像高度，以像素为单位，正数表示倒置图像
  unsigned short biPlanes; // 总是设置为1
  unsigned short biBitCount; // 每个像素的位数，常见值有1、4、8、16、24和32
  unsigned int
      biCompression; // 压缩类型，常见值有BI_RGB（无压缩）、BI_RLE8、BI_RLE4、BI_BITFIELDS等
  unsigned int biSizeImage;     // 图像数据的大小，以字节为单位
  unsigned int biXPelsPerMeter; // 水平分辨率，单位为像素/米
  unsigned int biYPelsPerMeter; // 垂直分辨率，单位为像素/米
  unsigned int biClrUsed; // 实际使用的颜色数，如果为0则默认2的biBitCount次方
  unsigned int biClrImportant; // 重要颜色数，如果为0则所有颜色都重要
} __attribute__((packed)) BITMAPINFOHEADER;

uint8_t fixed_text_data[19][128] = {
    /* "当" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
     0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x00, 0x02, 0x01, 0x81, 0xC0,
     0x01, 0x81, 0x81, 0xC0, 0x01, 0xC1, 0x83, 0x00, 0x00, 0xE1, 0x86, 0x00,
     0x00, 0x61, 0x84, 0x00, 0x00, 0x61, 0x88, 0x00, 0x00, 0x01, 0x90, 0x00,
     0x00, 0x01, 0x80, 0x30, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x30,
     0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30,
     0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x03, 0xFF, 0xFF, 0xF0,
     0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30,
     0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30,
     0x00, 0x00, 0x00, 0x30, 0x1F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x30,
     0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, /*"当",0*/
     /* (32 X 32 , 宋体 )*/},
    /* "前" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00,
     0x00, 0x20, 0x0E, 0x00, 0x00, 0x38, 0x0C, 0x00, 0x00, 0x18, 0x08, 0x00,
     0x00, 0x18, 0x10, 0x00, 0x00, 0x08, 0x20, 0x18, 0x3F, 0xFF, 0xFF, 0xFC,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x04, 0x04, 0x00, 0xE0,
     0x07, 0xFF, 0x10, 0xC0, 0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0,
     0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0, 0x07, 0xFE, 0x18, 0xC0,
     0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0,
     0x07, 0xFE, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0,
     0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x18, 0xC0, 0x06, 0x06, 0x00, 0x40,
     0x06, 0x06, 0x00, 0xC0, 0x06, 0x3C, 0x0F, 0xC0, 0x06, 0x1C, 0x03, 0x80,
     0x04, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, /*"前",1*/
     /* (32 X 32 , 宋体 )*/},
    /* "开" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x1F, 0xFF, 0xFF, 0xF8,
     0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00,
     0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00,
     0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x18,
     0x3F, 0xFF, 0xFF, 0xFC, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00,
     0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x30, 0x0C, 0x00,
     0x00, 0x20, 0x0C, 0x00, 0x00, 0x60, 0x0C, 0x00, 0x00, 0x60, 0x0C, 0x00,
     0x00, 0xC0, 0x0C, 0x00, 0x00, 0x80, 0x0C, 0x00, 0x01, 0x00, 0x0C, 0x00,
     0x02, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x0C, 0x00, 0x18, 0x00, 0x0C, 0x00,
     0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, /*"开",2*/
     /* (32 X 32 , 宋体 )*/},
    /* "发" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
     0x00, 0x06, 0x08, 0x00, 0x03, 0x06, 0x06, 0x00, 0x03, 0x04, 0x03, 0x00,
     0x03, 0x0C, 0x03, 0x80, 0x06, 0x0C, 0x01, 0x80, 0x06, 0x0C, 0x00, 0x80,
     0x0C, 0x0C, 0x00, 0x18, 0x1F, 0xFF, 0xFF, 0xFC, 0x08, 0x08, 0x00, 0x00,
     0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00, 0x80,
     0x00, 0x3F, 0xFF, 0xC0, 0x00, 0x34, 0x01, 0x80, 0x00, 0x32, 0x03, 0x80,
     0x00, 0x62, 0x03, 0x00, 0x00, 0x61, 0x06, 0x00, 0x00, 0x41, 0x86, 0x00,
     0x00, 0xC0, 0xCC, 0x00, 0x00, 0x80, 0x58, 0x00, 0x01, 0x80, 0x70, 0x00,
     0x03, 0x00, 0x78, 0x00, 0x02, 0x00, 0xFC, 0x00, 0x04, 0x01, 0x8F, 0x00,
     0x08, 0x07, 0x03, 0xC0, 0x10, 0x0C, 0x01, 0xFC, 0x20, 0x70, 0x00, 0x78,
     0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*"发",3*/
     /* (32 X 32 , 宋体 )*/},
    /* "板" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
     0x03, 0x80, 0x00, 0xE0, 0x03, 0x00, 0x03, 0xF0, 0x03, 0x02, 0x3E, 0x00,
     0x03, 0x03, 0xC0, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x33, 0x00, 0x00,
     0x3F, 0xFB, 0x00, 0x00, 0x03, 0x03, 0x00, 0x20, 0x03, 0x03, 0xFF, 0xF0,
     0x03, 0x03, 0x40, 0x60, 0x07, 0x83, 0x40, 0x40, 0x07, 0x43, 0x20, 0xC0,
     0x07, 0x73, 0x20, 0xC0, 0x07, 0x33, 0x20, 0x80, 0x0F, 0x13, 0x21, 0x80,
     0x0B, 0x13, 0x11, 0x80, 0x1B, 0x02, 0x13, 0x00, 0x13, 0x02, 0x1B, 0x00,
     0x13, 0x06, 0x0E, 0x00, 0x23, 0x06, 0x0C, 0x00, 0x43, 0x04, 0x0E, 0x00,
     0x03, 0x04, 0x1B, 0x00, 0x03, 0x0C, 0x33, 0x80, 0x03, 0x08, 0x41, 0xC0,
     0x03, 0x11, 0x80, 0xF0, 0x03, 0x26, 0x00, 0x7E, 0x03, 0x48, 0x00, 0x30,
     0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*"板",4*/
     /* (32 X 32 , 宋体 )*/},
    /* "I" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x1F, 0xF8, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,
     0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x1F,
     0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*"I",0*/
     /* (16 X 32 , 宋体 )*/},
    /* "P" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x7F, 0xF0, 0x18, 0x18, 0x18, 0x0C, 0x18, 0x06, 0x18, 0x06,
     0x18, 0x06, 0x18, 0x06, 0x18, 0x06, 0x18, 0x06, 0x18, 0x0C, 0x18,
     0x18, 0x1F, 0xE0, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00,
     0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x7E,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*"P",6*/
     /* (16 X 32 , 宋体 )*/},
    /* "为" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
     0x00, 0x01, 0xE0, 0x00, 0x02, 0x01, 0x80, 0x00, 0x01, 0x81, 0x80, 0x00,
     0x00, 0xC1, 0x80, 0x00, 0x00, 0xE1, 0x80, 0x00, 0x00, 0x61, 0x80, 0x00,
     0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x08, 0x1F, 0xFF, 0xFF, 0xFC,
     0x00, 0x03, 0x00, 0x18, 0x00, 0x03, 0x00, 0x18, 0x00, 0x03, 0x00, 0x18,
     0x00, 0x06, 0x00, 0x18, 0x00, 0x06, 0x40, 0x18, 0x00, 0x06, 0x30, 0x18,
     0x00, 0x0C, 0x1C, 0x18, 0x00, 0x0C, 0x0E, 0x18, 0x00, 0x18, 0x07, 0x18,
     0x00, 0x18, 0x03, 0x30, 0x00, 0x30, 0x02, 0x30, 0x00, 0x60, 0x00, 0x30,
     0x00, 0xE0, 0x00, 0x30, 0x00, 0xC0, 0x00, 0x30, 0x01, 0x80, 0x00, 0x30,
     0x02, 0x00, 0x30, 0x70, 0x0C, 0x00, 0x0F, 0xE0, 0x18, 0x00, 0x03, 0xC0,
     0x20, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, /*"为",7*/
     /* (32 X 32 , 宋体 )*/},
    /* "-" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F,
     0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*"-",8*/
     /* (16 X 32 , 宋体 )*/},
    /* "-" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F,
     0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*"-",8*/
     /* (16 X 32 , 宋体 )*/},
    /* ">" 的点阵数据 */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x20, 0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00,
     0x01, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00,
     0x08, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80,
     0x01, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x20,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*">",10*/
     /* (16 X 32 , 宋体 )*/}};

// 获取字符的 16x32 点阵数据
uint8_t *get_char_data_16x32(char c) {
  uint8_t *data = (uint8_t *)malloc(64); // 32x32点阵需要 16*32/8 = 64 字节

  if (data == NULL) {
    printf("内存分配失败！\n");
    exit(EXIT_FAILURE);
  }

  memset(data, 0, 64); // 初始化为0

  switch (c) {
  case '0': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0xC0, 0x06, 0x20, 0x0C, 0x30, 0x18, 0x18, 0x18, 0x18,
        0x18, 0x08, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30,
        0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C,
        0x18, 0x08, 0x18, 0x18, 0x18, 0x18, 0x0C, 0x30, 0x06, 0x20, 0x03,
        0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"0",0*/};
    memcpy(data, temp, 64);
    break;
  }
  case '1': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x01, 0x80, 0x1F, 0x80, 0x01, 0x80, 0x01, 0x80,
        0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01,
        0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
        0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x03, 0xC0, 0x1F,
        0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"1",1*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '2': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x07, 0xE0, 0x08, 0x38, 0x10, 0x18, 0x20, 0x0C, 0x20, 0x0C,
        0x30, 0x0C, 0x30, 0x0C, 0x00, 0x0C, 0x00, 0x18, 0x00, 0x18, 0x00,
        0x30, 0x00, 0x60, 0x00, 0xC0, 0x01, 0x80, 0x03, 0x00, 0x02, 0x00,
        0x04, 0x04, 0x08, 0x04, 0x10, 0x04, 0x20, 0x0C, 0x3F, 0xF8, 0x3F,
        0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"2",2*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '3': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x07, 0xC0, 0x18, 0x60, 0x30, 0x30, 0x30, 0x18, 0x30, 0x18,
        0x30, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x30, 0x00, 0x60, 0x03,
        0xC0, 0x00, 0x70, 0x00, 0x18, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x0C,
        0x30, 0x0C, 0x30, 0x0C, 0x30, 0x08, 0x30, 0x18, 0x18, 0x30, 0x07,
        0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"3",3*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '4': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x60, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xE0, 0x01, 0x60,
        0x01, 0x60, 0x02, 0x60, 0x04, 0x60, 0x04, 0x60, 0x08, 0x60, 0x08,
        0x60, 0x10, 0x60, 0x30, 0x60, 0x20, 0x60, 0x40, 0x60, 0x7F, 0xFC,
        0x00, 0x60, 0x00, 0x60, 0x00, 0x60, 0x00, 0x60, 0x00, 0x60, 0x03,
        0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"4",4*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '5': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0F, 0xFC, 0x0F, 0xFC, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00,
        0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x13, 0xE0, 0x14, 0x30, 0x18,
        0x18, 0x10, 0x08, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C,
        0x30, 0x0C, 0x30, 0x0C, 0x20, 0x18, 0x20, 0x18, 0x18, 0x30, 0x07,
        0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"5",5*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '6': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0xE0, 0x06, 0x18, 0x0C, 0x18, 0x08, 0x18, 0x18, 0x00,
        0x10, 0x00, 0x10, 0x00, 0x30, 0x00, 0x33, 0xE0, 0x36, 0x30, 0x38,
        0x18, 0x38, 0x08, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0x0C,
        0x30, 0x0C, 0x18, 0x0C, 0x18, 0x08, 0x0C, 0x18, 0x0E, 0x30, 0x03,
        0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"6",6*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '7': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x1F, 0xFC, 0x1F, 0xFC, 0x10, 0x08, 0x30, 0x10, 0x20, 0x10,
        0x20, 0x20, 0x00, 0x20, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00,
        0x80, 0x00, 0x80, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"7",7*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '8': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x07, 0xE0, 0x0C, 0x30, 0x18, 0x18, 0x30, 0x0C, 0x30, 0x0C,
        0x30, 0x0C, 0x38, 0x0C, 0x38, 0x08, 0x1E, 0x18, 0x0F, 0x20, 0x07,
        0xC0, 0x18, 0xF0, 0x30, 0x78, 0x30, 0x38, 0x60, 0x1C, 0x60, 0x0C,
        0x60, 0x0C, 0x60, 0x0C, 0x60, 0x0C, 0x30, 0x18, 0x18, 0x30, 0x07,
        0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"8",8*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '9': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x07, 0xC0, 0x18, 0x20, 0x30, 0x10, 0x30, 0x18, 0x60, 0x08,
        0x60, 0x0C, 0x60, 0x0C, 0x60, 0x0C, 0x60, 0x0C, 0x60, 0x0C, 0x70,
        0x1C, 0x30, 0x2C, 0x18, 0x6C, 0x0F, 0x8C, 0x00, 0x0C, 0x00, 0x18,
        0x00, 0x18, 0x00, 0x10, 0x30, 0x30, 0x30, 0x60, 0x30, 0xC0, 0x0F,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 /*"9",9*/
        /* (16 X 32 , 宋体 )*/};
    memcpy(data, temp, 64);
    break;
  }
  case '.': {
    uint8_t temp[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*".",0*/
        /* (16 X 32 , @微软雅黑 )*/

    };
    memcpy(data, temp, 64);
    break;
  }
  }
  return data;
}

// 显示字符或汉字在 LCD 上
void display_char_or_hanzi_on_lcd(uint32_t (*lcd)[800], uint8_t *data,
                                  int char_width, int char_height, int x_offset,
                                  int y_offset, int scale) {
  if (!lcd || !data)
    return;

  for (int row = 0; row < char_height; row++) {
    for (int byte_index = 0; byte_index < char_width / 8; byte_index++) {
      uint8_t ch = data[row * (char_width / 8) + byte_index];
      for (int column = 0; column < 8; column++) {
        int pixel = (ch & (0x80 >> column)) ? 0xFFFFFF : 0x000000; // 白色或黑色
        // 放大显示：每个点用 scale x scale 的方块表示
        for (int dx = 0; dx < scale; dx++) {
          for (int dy = 0; dy < scale; dy++) {
            lcd[y_offset + row * scale + dy]
               [x_offset + (byte_index * 8 + column) * scale + dx] = pixel;
          }
        }
      }
    }
  }
}

// 映射 LCD 设备
uint32_t (*mmap_lcd())[800] {
  int fd = open("/dev/fb0", O_RDWR);
  if (fd < 0) {
    perror("打开LCD失败");
    return NULL;
  }

  uint32_t(*lcd)[800] =
      mmap(NULL, 800 * 480 * 4, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  if (lcd == MAP_FAILED) {
    perror("映射失败");
    close(fd);
    return NULL;
  }

  close(fd);
  return lcd;
}

// 清除 LCD 显示
void lcd_clear(uint32_t (*lcd)[800], uint32_t color) {
  for (int y = 0; y < 480; y++) {
    for (int x = 0; x < 800; x++) {
      lcd[y][x] = color;
    }
  }
}

// 显示固定文本在 LCD 上
void display_fixed_text_on_lcd(uint32_t (*lcd)[800], int x_offset, int y_offset,
                               int scale) {
  int x = x_offset;

  for (int i = 0; i < 11; i++) {
    // 根据字符的实际宽度和高度显示字符
    int char_width = (i == 5 || i == 6 || i == 8 || i == 9 || i == 10)
                         ? 16
                         : 32; // "IP" 是符号，其他是汉字
    int char_height = 32;
    display_char_or_hanzi_on_lcd(lcd, fixed_text_data[i], char_width,
                                 char_height, x, y_offset, scale);
    x += char_width * scale; // 移动到下一个字符位置
  }
}

// 显示字符串在 LCD 上
void display_string_on_lcd(uint32_t (*lcd)[800], const char *str, int x_offset,
                           int y_offset, int char_width, int char_height,
                           int scale) {
  int x = x_offset;
  int y = y_offset;
  while (*str) {
    // printf("%c\n", *str);
    uint8_t *data = get_char_data_16x32(*str);
    display_char_or_hanzi_on_lcd(lcd, data, char_width, char_height, x, y,
                                 scale);
    free(data);              // 释放字模数据内存
    x += char_width * scale; // 移动到下一个字符位置
    str++;
  }
}

int get_ip_address(char *buffer, size_t buflen) {
  FILE *fp;
  char cmd[] = "ifconfig | grep 'inet ' | awk '{print $2}' | awk 'NR==1 {print "
               "substr($0, 6)}'";

  // 使用 popen 执行命令并获取标准输出
  fp = popen(cmd, "r");
  if (fp == NULL) {
    perror("popen");
    return -1; // 错误返回
  }

  // 读取命令输出
  if (fgets(buffer, buflen, fp) != NULL) {
    // 去除末尾换行符
    buffer[strcspn(buffer, "\n")] = '\0';
  } else {
    // 读取失败
    perror("fgets");
    pclose(fp);
    return -1; // 错误返回
  }

  // 关闭文件流
  if (pclose(fp) == -1) {
    perror("pclose");
    return -1; // 错误返回
  }

  return 0; // 成功返回
}

int main(int argc, char *argv[]) {

  // // 检查命令行参数
  // if (argc != 2) {
  //   fprintf(stderr, "用法: %s <bmp文件路径>\n", argv[0]);
  //   return EXIT_FAILURE;
  // }

  // 打开 BMP 图片文件
  int fd = open("./.bg.bmp", O_RDONLY);
  if (fd < 0) {
    perror("打开文件失败");
    return EXIT_FAILURE;
  }

  // 读取 BMP 文件头
  BITMAPFILEHEADER fileHeader;
  if (read(fd, &fileHeader, sizeof(BITMAPFILEHEADER)) !=
      sizeof(BITMAPFILEHEADER)) {
    perror("读取文件头失败");
    close(fd);
    return EXIT_FAILURE;
  }

  // 读取 BMP 位图信息头
  BITMAPINFOHEADER infoHeader;
  if (read(fd, &infoHeader, sizeof(BITMAPINFOHEADER)) !=
      sizeof(BITMAPINFOHEADER)) {
    perror("读取位图信息头失败");
    close(fd);
    return EXIT_FAILURE;
  }

  // 输出 BMP 文件头信息
  printf("BMP 文件大小: %u 字节\n", fileHeader.bfSize);
  printf("图像宽度: %u 像素\n", infoHeader.biWidth);
  printf("图像高度: %u 像素\n", infoHeader.biHeight);
  printf("色深: %u 位\n", infoHeader.biBitCount);

  // 分配内存来存储图像的像素数据
  size_t imageSize =
      infoHeader.biWidth * infoHeader.biHeight * infoHeader.biBitCount / 8;
  char *rgb = malloc(imageSize);
  if (!rgb) {
    perror("内存分配失败");
    close(fd);
    return EXIT_FAILURE;
  }

  // 读取图像像素数据
  if (lseek(fd, fileHeader.bfOffBits, SEEK_SET) == -1 ||
      read(fd, rgb, imageSize) != (ssize_t)imageSize) {
    perror("读取像素数据失败");
    free(rgb);
    close(fd);
    return EXIT_FAILURE;
  }

  uint32_t(*lcd)[800] = mmap_lcd();
  if (!lcd) {
    return -1;
  }

  lcd_clear(lcd, 0x000000); // 清屏，黑色背景

  // 计算显示图像的起始位置，使图像居中
  int startX = (800 - infoHeader.biWidth / 2) / 2;
  int startY = (480 - infoHeader.biHeight / 2) / 2;

  // 将 RGB 数据转换为 LCD 可用的颜色格式，并将其显示到 LCD 屏幕
  for (int lcdY = startY, bmpY = 0; lcdY < startY + infoHeader.biHeight / 2;
       lcdY++, bmpY += 2) {
    for (int lcdX = startX, bmpX = 0; lcdX < startX + infoHeader.biWidth / 2;
         lcdX++, bmpX += 2) {
      char b = rgb[(bmpY * infoHeader.biWidth + bmpX) * 3 + 0];
      char g = rgb[(bmpY * infoHeader.biWidth + bmpX) * 3 + 1];
      char r = rgb[(bmpY * infoHeader.biWidth + bmpX) * 3 + 2];
      lcd[infoHeader.biHeight - lcdY - 1][lcdX] =
          b | (g << 8) | (r << 16) | (0 << 24);
    }
  }

  // 释放资源
  free(rgb);

  char ip[INET_ADDRSTRLEN];

  // 获取 IP 地址
  if (get_ip_address(ip, sizeof(ip)) != 0) {
    fprintf(stderr, "获取IP地址失败\n");
    return EXIT_FAILURE;
  }

  // printf("%s\n", ip);

  // 显示固定文本
  display_fixed_text_on_lcd(lcd, 0, 400, 2);

  // 显示 IP 地址
  display_string_on_lcd(lcd, ip, 550, 416, 16, 32, 1);

  // 维持显示一段时间
  sleep(10);

  // 解除映射
  munmap(lcd, 800 * 480 * 4);

  return 0;
}
