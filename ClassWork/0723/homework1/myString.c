/****************************************************************************************************************************************************************
 * @file         : /Tools/home/user/Code/ClassWork/0723/homework1/myString.c
 * @brief        : 字符串操作函数实现
 * @author       : a_23456@foxmail.com
 * @date         : 2024-07-23 19:17:25
 * @version      : 1.0
 * @note         : 提供字符串长度计算、复制、连接、查找等功能
 * @Copyright    : (c) 2024-2025 a_23456@foxmail.com All Right Reserved
 *****************************************************************************************************************************************************************/

#include "myString.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

/****************************************************************************************************************************************************************
 * @name: myStrlen
 * @brief: 计算字符串的长度
 * @param {const char} *s  - 指向以 null 结尾的字符串
 * @return {int} - 字符串的长度，不包括 null 终止符
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数用于计算字符串的字符数，不包括 null 终止符。
 *****************************************************************************************************************************************************************/
int myStrlen(const char *str) {
  int length = 0;        // 初始化长度计数器
  while (*str != '\0') { // 遍历字符串直到末尾
    str++;               // 移动到下一个字符
    length++;            // 增加长度计数器
  }
  return length; // 返回字符串长度
}

/****************************************************************************************************************************************************************
 * @name: myStrcpy
 * @brief: 复制字符串
 * @param {char} *dest - 目标字符串缓冲区，必须足够大以容纳源字符串及终止符
 * @param {const char} *src - 源字符串
 * @return {char*} - 返回指向目标字符串的指针
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数将源字符串复制到目标字符串缓冲区。
 *****************************************************************************************************************************************************************/
char *myStrcpy(char *dest, const char *src) {
  char *original_dest = dest; // 保存目标字符串的起始地址
  while (*src != '\0') {      // 遍历源字符串直到末尾
    *dest = *src;             // 复制字符到目标字符串
    dest++;                   // 移动到目标字符串的下一个位置
    src++;                    // 移动到源字符串的下一个位置
  }
  *dest = '\0';         // 添加 null 终止符
  return original_dest; // 返回目标字符串的起始地址
}

/****************************************************************************************************************************************************************
 * @name: myStrncpy
 * @brief: 复制指定长度的字符串
 * @param {char} *dest - 目标字符串缓冲区，必须足够大以容纳指定长度的字符串
 * @param {const char} *src - 源字符串
 * @param {int} n - 复制的最大字符数
 * @return {char*} - 返回指向目标字符串的指针
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数将源字符串的前 n
 *个字符复制到目标字符串缓冲区。如果源字符串长度小于 n，则目标字符串将被填充
 *null 终止符。
 *****************************************************************************************************************************************************************/
char *myStrncpy(char *dest, const char *src, int n) {
  char *original_dest = dest;   // 保存目标字符串的起始地址
  for (int i = 0; i < n; i++) { // 遍历 n 个字符
    if (*src != '\0') {         // 如果源字符串未到达末尾
      *dest = *src;             // 复制字符到目标字符串
      src++;                    // 移动到源字符串的下一个位置
    } else {
      *dest = '\0'; // 填充 null 终止符
    }
    dest++; // 移动到目标字符串的下一个位置
  }
  return original_dest; // 返回目标字符串的起始地址
}

/****************************************************************************************************************************************************************
 * @name: myBzero
 * @brief: 将内存区域设置为零
 * @param {void} *s - 指向要设置的内存区域
 * @param {int} n - 要设置的字节数
 * @return {void} - 无返回值
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数将指定内存区域的前 n 个字节设置为零。此函数类似于 `memset`。
 *****************************************************************************************************************************************************************/
void myBzero(void *s, int n) {
  char *ptr = s; // 将 void* 转换为 char* 以便逐字节操作
  for (int i = 0; i < n; i++) { // 遍历 n 个字节
    *ptr = '\0';                // 将当前字节设置为零
    ptr++;                      // 移动到下一个字节
  }
}

/****************************************************************************************************************************************************************
 * @name: myStrcat
 * @brief: 连接两个字符串
 * @param {char} *dest - 目标字符串，必须足够大以容纳源字符串及终止符
 * @param {const char} *src - 源字符串
 * @return {char*} - 返回指向目标字符串的指针
 * @date: 2024-07-23
 * @version: 1.0
 * @note:
 *该函数将源字符串追加到目标字符串的末尾，目标字符串必须有足够的空间来存储结果。
 *****************************************************************************************************************************************************************/
char *myStrcat(char *dest, const char *src) {
  char *original_dest = dest; // 保存目标字符串的起始地址
  dest += myStrlen(dest);     // 将指针移动到目标字符串末尾
  while (*src != '\0') {      // 遍历源字符串直到末尾
    *dest = *src;             // 复制字符到目标字符串
    dest++;                   // 移动到目标字符串的下一个位置
    src++;                    // 移动到源字符串的下一个位置
  }
  *dest = '\0';         // 添加 null 终止符
  return original_dest; // 返回目标字符串的起始地址
}

/****************************************************************************************************************************************************************
 * @name: myStrchr
 * @brief: 查找字符串中第一次出现指定字符的位置
 * @param {const char} *s - 要搜索的字符串
 * @param {int} c - 要查找的字符
 * @return {char*} - 返回指向第一次出现字符的位置的指针，如果未找到则返回 NULL
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数在字符串中查找第一次出现的字符，并返回该位置的指针。
 *****************************************************************************************************************************************************************/
char *myStrchr(const char *str, int c) {
  while (*str != '\0') {   // 遍历字符串直到末尾
    if (*str == (char)c) { // 如果找到字符 c
      return (char *)str;  // 返回指向该字符的指针
    }
    str++; // 移动到下一个字符
  }
  return NULL; // 未找到字符，返回 NULL
}

/****************************************************************************************************************************************************************
 * @name: myStrcmp
 * @brief: 比较两个字符串
 * @param {const char} *s1 - 第一个字符串
 * @param {const char} *s2 - 第二个字符串
 * @return {int} - 返回值小于、等于或大于零，分别表示 s1 小于、等于或大于 s2
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数比较两个字符串并返回差异的整数值。
 *****************************************************************************************************************************************************************/
int myStrcmp(const char *str1, const char *str2) {
  while (*str1 != '\0' && *str2 != '\0') { // 遍历字符串直到其中一个到达末尾
    if (*str1 != *str2) {                  // 如果字符不同
      return *str1 - *str2;                // 返回字符差异
    }
    str1++; // 移动到下一个字符
    str2++; // 移动到下一个字符
  }
  return *str1 - *str2; // 考虑字符串长度不同的情况，返回字符差异
}

/****************************************************************************************************************************************************************
 * @name: myStrncasecmp
 * @brief: 比较两个字符串的前 n 个字符，不区分大小写
 * @param {const char} *s1 - 第一个字符串
 * @param {const char} *s2 - 第二个字符串
 * @param {int} n - 要比较的字符数
 * @return {int} - 返回值小于、等于或大于零，分别表示 s1 小于、等于或大于 s2
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数比较两个字符串的前 n 个字符，不区分大小写。
 *****************************************************************************************************************************************************************/
int myStrncasecmp(const char *str1, const char *str2, int n) {
  for (int i = 0; i < n && (*str1 != '\0' || *str2 != '\0');
       i++) { // 遍历 n 个字符或直到其中一个字符串结束
    char c1 = (*str1 >= 'a' && *str1 <= 'z')
                  ? *str1 - 32
                  : *str1; // 将小写字母转换为大写字母
    char c2 = (*str2 >= 'a' && *str2 <= 'z')
                  ? *str2 - 32
                  : *str2; // 将小写字母转换为大写字母
    if (c1 != c2) {        // 如果字符不同
      return c1 - c2;      // 返回字符差异
    }
    str1++; // 移动到下一个字符
    str2++; // 移动到下一个字符
  }
  return 0; // 字符串前 n 个字符相同，返回 0
}

/****************************************************************************************************************************************************************
 * @name: myStrdup
 * @brief: 复制字符串并返回新分配的内存指针
 * @param {const char} *s - 要复制的字符串
 * @return {char*} -
 *返回指向新分配内存中复制字符串的指针，如果内存分配失败则返回 NULL
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数为字符串分配新内存并进行复制，返回新字符串的指针。
 *****************************************************************************************************************************************************************/
char *myStrdup(const char *str) {
  int len = myStrlen(str) + 1; // 计算字符串长度，加 1 是为了包含 null 终止符
  char *dup = malloc(len * sizeof(char)); // 为新字符串分配内存
  if (dup == NULL) {                      // 如果内存分配失败
    return NULL;                          // 返回 NULL
  }
  myStrcpy(dup, str); // 复制字符串到新内存
  return dup;         // 返回新字符串的指针
}

/****************************************************************************************************************************************************************
 * @name: myStrstr
 * @brief: 查找字符串中第一次出现指定子字符串的位置
 * @param {const char} *haystack - 要搜索的字符串
 * @param {const char} *needle - 要查找的子字符串
 * @return {char*} - 返回指向第一次出现子字符串的位置的指针，如果未找到则返回
 *NULL
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数在字符串中查找第一次出现的子字符串，并返回该位置的指针。
 *****************************************************************************************************************************************************************/
char *myStrstr(const char *haystack, const char *needle) {
  if (*needle == '\0') {     // 如果要查找的子字符串为空
    return (char *)haystack; // 返回原字符串的指针
  }
  while (*haystack != '\0') { // 遍历字符串直到末尾
    const char *h = haystack;
    const char *n = needle;
    while (*h != '\0' && *n != '\0' && *h == *n) { // 同时遍历主字符串和子字符串
      h++;
      n++;
    }
    if (*n == '\0') {          // 如果子字符串遍历完毕
      return (char *)haystack; // 返回匹配位置的指针
    }
    haystack++; // 移动到主字符串的下一个位置
  }
  return NULL; // 未找到子字符串，返回 NULL
}

/****************************************************************************************************************************************************************
 * @name: myStrtok
 * @brief: 分割字符串
 * @param {char} *str - 要分割的字符串
 * @param {const char} *delim - 分隔符字符串
 * @return {char*} - 返回指向当前分割字段的指针，如果没有更多字段则返回 NULL
 * @date: 2024-07-23
 * @version: 1.0
 * @note: 该函数用于分割字符串，将其分割成多个字段，根据分隔符进行分割。
 *****************************************************************************************************************************************************************/
char *myStrtok(char *str, const char *delim) {
  static char *lasts; // 保存上一次调用后的位置
  if (str == NULL) {  // 如果 str 为 NULL
    str = lasts;      // 使用上一次保存的位置
  }
  if (str == NULL) { // 如果仍然为 NULL
    return NULL;     // 返回 NULL
  }

  // 跳过前导分隔符
  str += strspn(str, delim);
  if (*str == '\0') { // 如果到达字符串末尾
    lasts = NULL;     // 清除 lasts
    return NULL;      // 返回 NULL
  }

  // 查找下一个分隔符
  char *token = str;           // 保存当前分割字段的起始位置
  str = strpbrk(token, delim); // 查找下一个分隔符位置
  if (str == NULL) {           // 如果未找到分隔符
    lasts = NULL;              // 清除 lasts
  } else {
    *str = '\0';     // 将分隔符替换为 null 终止符
    lasts = str + 1; // 更新 lasts 为下一个位置
  }
  return token; // 返回当前分割字段
}

/****************************************************************************************************************************************************************
 * @name: myAtoi
 * @brief: 将字符串转换为整数
 * @param {const char} *nptr - 要转换的字符串
 * @return {int} - 转换后的整数值
 * @date: 2024-07-24 10:17:01
 * @version: 1.0
 * @note: 该函数将表示整数的字符串转换为整数值。
 *****************************************************************************************************************************************************************/
int myAtoi(const char *nptr) {
  int result = 0;        // 初始化结果变量
  while (*nptr == ' ') { // 跳过前导空格
    nptr++;
  }

  int sign = 1;                       // 默认正数
  if (*nptr == '-' || *nptr == '+') { // 检查正负号
    if (*nptr == '-') {
      sign = -1; // 如果是负号，则设置符号为负
    }
    nptr++; // 跳过符号字符
  }

  while (*nptr >= '0' && *nptr <= '9') {  // 遍历数字字符
    result = result * 10 + (*nptr - '0'); // 累加数字值
    nptr++;
  }

  return sign * result; // 返回带符号的结果值
}
