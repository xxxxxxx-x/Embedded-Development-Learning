/****************************************************************************************************************************************************************
 * @file         : /ClassWork/0718/homework5.c
 * @brief        :
 *                 作业：在
 *                 x86平台下，分析以下代码的输出结果（x86平台一般是小端，即低字节存低地址）
 * @author       : a_23456@foxmail.com
 * @date         : 2024-07-18 21:19:02
 * @version      : 1.0
 * @note         :
 * @Copyright    : (c)   2024-2025   a_23456@foxmail.com   All Right Reserved
 *****************************************************************************************************************************************************************/

#include <stdio.h>

int main(void) {
  int a[4] = {1, 2, 3, 4}; // 一个数组有四个元素，每个元素都是int类型
  // &a + 1表示跳过整个数组的地址，所以ptr1会指向数组之后的地址
  int *ptr1 = (int *)(&a + 1);
  // (int)a +
  // 1表示将数组a的地址转换为整数后加1，再强制转换为int指针，所以ptr2指向偏移一个字节后的地址
  int *ptr2 = (int *)((int)a + 1);

  // 输出数组每个元素的地址和值
  for (int i = 0; i < 4; i++) {
    printf("%p[%d] ", &(a[i]), a[i]);
  }
  printf("\n");

  // 输出数组结束后的地址，实际上是无效访问
  printf("%p ", &(a[4]));
  printf("\n");

  // 输出&a的地址，指向整个数组
  printf("&a ==> %p\n", &a);
  // 输出ptr1的值，即数组结束后的地址
  printf("ptr1 %%p==> %p\n", ptr1);
  // 输出ptr1指向的值，由于ptr1指向的是数组结束后的地址，实际值是未定义的
  printf("ptr1 %%d==> %d\n", *ptr1);
  // 输出ptr2的值，指向偏移一个字节后的地址
  printf("ptr2 %%p==> %p\n", ptr2);
  // 输出ptr2指向的值，由于指向的是偏移一个字节后的地址，读取值也是未定义的
  printf("ptr2 %%d==> %d\n", *ptr2);
  // 输出ptr1[-1]，即数组最后一个元素的值，和ptr2指向的值
  printf("%x, %x\n", ptr1[-1], *ptr2);

  return 0;
}
