/****************************************************************************************************************************************************************
 * @file         : /Code/ClassWork/0802/demo2/kernel_list.h
 * @brief        : 内核链表实现
 * @date         : 2024-08-02 20:21:48
 * @version      : 1.0
 *****************************************************************************************************************************************************************/
#ifndef KERNEL_LIST_H
#define KERNEL_LIST_H

/****************************************************************************************************************************************************************
 * @name: OFFSETOF
 * @brief: 获取成员在结构体中的偏移量
 * @param {TYPE} - 结构体类型
 * @param {MEMBER} - 成员名
 * @return {size_t} - 成员的偏移量
 * @date: 2024-08-03 09:10:10
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define OFFSETOF(TYPE, MEMBER) ((size_t) & ((TYPE *)0)->MEMBER)

/****************************************************************************************************************************************************************
 * @name: CONTAINER_OF
 * @brief: 获取包含某成员的结构体指针
 * @param {void*} PTR - 成员指针
 * @param {TYPE} TYPE - 结构体类型
 * @param {MEMBER} MEMBER - 成员名
 * @return {type*} - 结构体指针
 * @date: 2024-08-03 09:10:59
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define CONTAINER_OF(PTR, TYPE, MEMBER)                                        \
  ({                                                                           \
    const typeof(((TYPE *)0)->MEMBER) *__mptr = (PTR);                         \
    (TYPE *)((char *)__mptr - OFFSETOF(TYPE, MEMBER));                         \
  })

/****************************************************************************************************************************************************************
 * @name: LIST_POISON1
 * @brief: 第一个无效指针，用于检测
 * @param {void} *
 * @return {*}
 * @date: 2024-08-03 09:11:08
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_POISON1 ((struct list_head *)0x00100100)

/****************************************************************************************************************************************************************
 * @name: LIST_POISON2
 * @brief: 第二个无效指针，用于检测
 * @param {void} *
 * @return {*}
 * @date: 2024-08-03 09:11:16
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_POISON2 ((struct list_head *)0x00200)

/****************************************************************************************************************************************************************
 * @name: LIST_HEAD_INIT
 * @brief: 初始化链表头
 * @param {struct list_head} NAME - 链表头
 * @return {struct list_head} - 初始化后的链表头
 * @date: 2024-08-03 09:10:04
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_HEAD_INIT(NAME)                                                   \
  { &(NAME), &(NAME) }

/****************************************************************************************************************************************************************
 * @name: LIST_HEAD
 * @brief: 定义并初始化链表头
 * @param {list_head} NAME - 链表头
 * @return {*}
 * @date: 2024-08-03 09:11:44
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_HEAD(NAME) struct list_head NAME = LIST_HEAD_INIT(NAME)

/****************************************************************************************************************************************************************
 * @name: INIT_LIST_HEAD
 * @brief: 初始化链表头，将链表头的 `next` 和 `prev` 指针都指向自身
 * @param {struct list_head *} PTR 链表头指针
 * @return {void}
 * @date: 2024-08-03 09:09:58
 * @version: 1.0
 * @note:
 *****************************************************************************************************************************************************************/
#define INIT_LIST_HEAD(PTR)                                                    \
  (PTR)->next = (PTR);                                                         \
  (PTR)->prev = (PTR)

/****************************************************************************************************************************************************************
 * @name: DEFINE_LIST_HEAD
 * @brief: 定义并初始化一个链表头，并返回该链表头的对象
 * @param {struct list_head} NAME - 链表头的名称
 * @return {struct list_head} - 初始化后的链表头对象
 * @date: 2024-08-03 09:20:10
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define DEFINE_LIST_HEAD(NAME)                                                 \
  LIST_HEAD(NAME);                                                             \
  INIT_LIST_HEAD(&NAME)

/****************************************************************************************************************************************************************
 * @name: LIST_ENTRY
 * @brief: 获取链表元素结构体指针
 * @param {struct list_head*} PTR - 链表节点指针
 * @param {type} TYPE - 结构体类型
 * @param {member} MEMBER - 成员名
 * @return {type*} - 结构体指针
 * @date: 2024-08-03 09:09:48
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_ENTRY(PTR, TYPE, MEMBER)                                          \
  ((TYPE *)((char *)(PTR) - OFFSETOF(TYPE, MEMBER)))

/****************************************************************************************************************************************************************
 * @name: LIST_FOR_EACH
 * @brief: 遍历链表
 * @param {struct list_head*} POS - 用于遍历的指针
 * @param {struct list_head*} HEAD - 链表头
 * @return {*}
 * @date: 2024-08-03 09:09:43
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_FOR_EACH(POS, HEAD)                                               \
  for (POS = (HEAD)->next; POS != (HEAD); POS = POS->next)

/****************************************************************************************************************************************************************
 * @name: LIST_FOR_EACH_PREV
 * @brief: 反向遍历链表
 * @param {struct list_head*} POS - 用于遍历的指针
 * @param {struct list_head*} HEAD - 链表头
 * @return {*}
 * @date: 2024-08-03 09:09:10
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_FOR_EACH_PREV(POS, HEAD)                                          \
  for (POS = (HEAD)->prev; POS != (HEAD); POS = POS->prev)

/****************************************************************************************************************************************************************
 * @name: LIST_FOR_EACH_SAFE
 * @brief: 遍历链表，安全地删除节点
 * @param {struct list_head*} POS - 用于遍历的指针
 * @param {struct list_head*} N - 临时存储下一个节点的指针
 * @param {struct list_head*} HEAD - 链表头
 * @return {*}
 * @date: 2024-08-03 09:09:05
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_FOR_EACH_SAFE(POS, N, HEAD)                                       \
  for (POS = (HEAD)->next, N = POS->next; POS != (HEAD); POS = N, N = POS->next)

/****************************************************************************************************************************************************************
 * @name: LIST_FOR_EACH_ENTRY
 * @brief: 遍历链表中的结构体元素
 * @param {type*} POS - 用于遍历的指针
 * @param {struct list_head*} HEAD - 链表头
 * @param {member} MEMBER - 成员名
 * @return {*}
 * @date: 2024-08-03 09:08:58
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_FOR_EACH_ENTRY(POS, HEAD, MEMBER)                                 \
  for (POS = LIST_ENTRY((HEAD)->next, typeof(*POS), MEMBER);                   \
       &POS->MEMBER != (HEAD);                                                 \
       POS = LIST_ENTRY(POS->MEMBER.next, typeof(*POS), MEMBER))

/****************************************************************************************************************************************************************
 * @name: LIST_FOR_EACH_ENTRY_SAFE
 * @brief: 遍历链表中的结构体元素，安全地删除节点
 * @param {type*} POS - 用于遍历的指针
 * @param {type*} N - 临时存储下一个节点的指针
 * @param {struct list_head*} HEAD - 链表头
 * @param {member} MEMBER - 成员名
 * @return {*}
 * @date: 2024-08-03 09:06:34
 * @version: 1.0
 *****************************************************************************************************************************************************************/
#define LIST_FOR_EACH_ENTRY_SAFE(POS, N, HEAD, MEMBER)                         \
  for (POS = LIST_ENTRY((HEAD)->next, typeof(*POS), MEMBER),                   \
      N = LIST_ENTRY(POS->MEMBER.next, typeof(*POS), MEMBER);                  \
       &POS->MEMBER != (HEAD);                                                 \
       POS = N, N = LIST_ENTRY(N->MEMBER.next, typeof(*N), MEMBER))

/****************************************************************************************************************************************************************
 * @name: struct list_head
 * @brief: 链表节点结构
 * @date: 2024-08-03 09:15:35
 * @version: 1.0
 *****************************************************************************************************************************************************************/
struct list_head {
  struct list_head *prev; // 指向前驱节点
  struct list_head *next; // 指向后继节点
};

/****************************************************************************************************************************************************************
 * @name: __list_add
 * @brief: 在两个已知节点之间插入新节点
 * @param {struct list_head*} new_node - 新节点
 * @param {struct list_head*} prev - 前驱节点
 * @param {struct list_head*} next - 后继节点
 * @return {*}
 * @date: 2024-08-03 09:15:56
 * @version: 1.0
 * @note: 内部使用，不直接调用
 *****************************************************************************************************************************************************************/
static inline void __list_add(struct list_head *new_node,
                              struct list_head *prev, struct list_head *next) {
  next->prev = new_node; // 新节点的下一个节点的前驱指向新节点
  new_node->next = next; // 新节点的下一个节点指向原来的下一个节点
  new_node->prev = prev; // 新节点的前驱指向原来的前驱节点
  prev->next = new_node; // 原来的前驱节点的下一个节点指向新节点
}

/****************************************************************************************************************************************************************
 * @name: list_add
 * @brief: 将新节点插入到链表头之后
 * @param {struct list_head*} new_node - 新节点
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 09:16:26
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_add(struct list_head *new_node,
                            struct list_head *head) {
  __list_add(new_node, head, head->next);
}

/****************************************************************************************************************************************************************
 * @name: list_add_tail
 * @brief: 将新节点插入到链表尾之前
 * @param {struct list_head*} new_node - 新节点
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 09:16:39
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_add_tail(struct list_head *new_node,
                                 struct list_head *head) {
  __list_add(new_node, head->prev, head);
}

/****************************************************************************************************************************************************************
 * @name: __list_del
 * @brief: 从链表中删除节点
 * @param {struct list_head*} prev - 前驱节点
 * @param {struct list_head*} next - 后继节点
 * @return {*}
 * @date: 2024-08-03 09:16:54
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void __list_del(struct list_head *prev, struct list_head *next) {
  next->prev = prev;
  prev->next = next;
}

/****************************************************************************************************************************************************************
 * @name: list_del
 * @brief: 删除指定节点
 * @param {struct list_head*} entry - 要删除的节点
 * @return {*}
 * @date: 2024-08-03 09:17:13
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_del(struct list_head *entry) {
  __list_del(entry->prev, entry->next);
  entry->next = LIST_POISON1;
  entry->prev = LIST_POISON2;
}

/****************************************************************************************************************************************************************
 * @name: list_del_init
 * @brief: 删除指定节点并重新初始化
 * @param {struct list_head*} entry - 要删除的节点
 * @return {*}
 * @date: 2024-08-03 09:17:28
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_del_init(struct list_head *entry) {
  __list_del(entry->prev, entry->next);
  INIT_LIST_HEAD(entry);
}

/****************************************************************************************************************************************************************
 * @name: list_empty
 * @brief: 检查链表是否为空
 * @param {struct list_head*} head - 链表头
 * @return {int} - 为空返回1，不为空返回0
 * @date: 2024-08-03 09:17:42
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline int list_empty(const struct list_head *head) {
  return head->next == head;
}

/****************************************************************************************************************************************************************
 * @name: list_move
 * @brief: 将指定节点移动到链表头之后
 * @param {struct list_head*} list - 要移动的节点
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 09:17:55
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_move(struct list_head *list, struct list_head *head) {
  __list_del(list->prev, list->next);
  list_add(list, head);
}

/****************************************************************************************************************************************************************
 * @name: list_move_tail
 * @brief: 将指定节点移动到链表尾之前
 * @param {struct list_head*} list - 要移动的节点
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 09:18:09
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_move_tail(struct list_head *list,
                                  struct list_head *head) {
  __list_del(list->prev, list->next);
  list_add_tail(list, head);
}

/****************************************************************************************************************************************************************
 * @name: __list_splice
 * @brief: 将链表 `list` 插入到链表 `head` 之后
 * @param {struct list_head*} list - 要插入的链表
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 14:51:37
 * @version: 1.0
 * @note: 内部使用，不直接调用
*****************************************************************************************************************************************************************/
static inline void __list_splice(struct list_head *list,
                                 struct list_head *head) {
  struct list_head *first = list->next; // 获取插入链表的第一个节点
  struct list_head *last = list->prev;  // 获取插入链表的最后一个节点
  struct list_head *at = head->next;    // 获取插入位置的下一个节点

  first->prev = head; // 插入链表的第一个节点的前驱指向插入位置
  head->next = first; // 插入位置的下一个节点指向插入链表的第一个节点

  last->next = at;    // 插入链表的最后一个节点的下一个节点指向插入位置的下一个节点
  at->prev = last;    // 插入位置的下一个节点的前驱指向插入链表的最后一个节点
}

/****************************************************************************************************************************************************************
 * @name: list_splice
 * @brief: 将链表 `list` 插入到链表 `head` 之后
 * @param {struct list_head*} list - 要插入的链表
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 14:51:53
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_splice(struct list_head *list, struct list_head *head) {
  if (!list_empty(list)) // 检查插入的链表是否为空
    __list_splice(list, head);
}

/****************************************************************************************************************************************************************
 * @name: list_splice_init
 * @brief: 将链表 `list` 插入到链表 `head` 之后并初始化 `list`
 * @param {struct list_head*} list - 要插入的链表
 * @param {struct list_head*} head - 链表头
 * @return {*}
 * @date: 2024-08-03 14:52:03
 * @version: 1.0
 *****************************************************************************************************************************************************************/
static inline void list_splice_init(struct list_head *list,
                                    struct list_head *head) {
  if (!list_empty(list)) { // 检查插入的链表是否为空
    __list_splice(list, head);
    INIT_LIST_HEAD(list); // 初始化插入的链表
  }
}

#endif // KERNEL_LIST_H
